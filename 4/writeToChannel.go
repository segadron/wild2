package main

import (
	"fmt"       // пакет для форматирования строк
	"os"        // пакет для работы с операционными системами
	"os/signal" // пакет для обработки сигналов
	"runtime"   // пакет для работы с информацией о системной среде
	"sync"      // пакет для работы с синхронизацией
	"syscall"   // пакет для работы со системными вызовами
)

// main - входная точка программы
func main() {
	// Запроси у пользователя количество рабочих потоков
	var numWorkers int
	fmt.Print("Enter number of workers: ")
	fmt.Scan(&numWorkers)
	// Если пользователь не ввел значение, используем количество ядер процессора
	if numWorkers < 1 {
		numWorkers = runtime.NumCPU()
	}

	// Каналы для обработки сигналов и передачи данных
	done := make(chan struct{})     // канал для остановки работы программы
	quit := make(chan os.Signal, 1) // канал для обработки сигналов завершения работы программы

	// Регистрируем сигналы завершения работы программы
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	dataCh := make(chan interface{}, numWorkers) // канал для передачи данных между рабочими потоками

	var wg sync.WaitGroup // группа синхронизации для ожидания завершения всех рабочих потоков
	wg.Add(numWorkers)    // добавим в группу синхронизации количество рабочих потоков

	// Создаем рабочие потоки и запускаем их
	for i := 0; i < numWorkers; i++ {
		go func() {
			// Завершение работы потока
			defer wg.Done()
			// Цикл приёма данных из канала
			for d := range dataCh {
				fmt.Println(d) // Вывод данных
			}
		}()
	}

	// ГорутаGenerator - поток генерации данных
	go func() {
		for {
			select {
			case <-done: // Если программа должна быть остановлена, выходим из цикла
				return
			default: // Если программа работает, генерируем данные
				dataCh <- "Какие-то данные" // Отправляем данные в канал
			}
		}
	}()

	// Обработчик сигналов завершения работы программы
	go func() {
		<-quit        // Ожидаем сигнал завершения работы программы
		close(done)   // Закрываем канал для остановки работы программы
		wg.Wait()     // Ожидаем завершения всех рабочих потоков
		close(dataCh) // Закрываем канал для передачи данных
	}()

	wg.Wait() // Ожидаем завершения всех рабочих потоков
}
